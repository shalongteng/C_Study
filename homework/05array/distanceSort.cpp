/**
 *Description
给出三维空间中的n个点（不超过10个）,求出n个点两两之间的距离,并按距离由大到小依次输出两个点的坐标及它们之间的距离。
Input
输入包括两行，第一行包含一个整数n表示点的个数，第二行包含每个点的坐标(坐标都是整数)。点的坐标的范围是0到100，输入数据中不存在坐标相同的点。
Output
对于大小为n的输入数据，输出n*(n-1)/2行格式如下的距离信息：
(x1,y1,z1)-(x2,y2,z2)=距离
其中距离保留到数点后面2位。
Sample Input
4
0 0 0 1 0 0 1 1 0 1 1 1
Sample Output
(0,0,0)-(1,1,1)=1.73
(0,0,0)-(1,1,0)=1.41
(1,0,0)-(1,1,1)=1.41
(0,0,0)-(1,0,0)=1.00
(1,0,0)-(1,1,0)=1.00
(1,1,0)-(1,1,1)=1.00
Hint
注意：
冒泡排序满足下面的性质,选择排序和快速排序(qsort或sort)需要对下面的情况进行额外处理
使用冒泡排序时要注意边界情况的处理,保证比较的两个数都在数组范围内


1. 对于一行输出中的两个点(x1,y1,z1)和(x2,y2,z2)，点(x1,y1,z1)在输入数据中应出现在点(x2,y2,z2)的前面。

    比如输入：
    2
    0 0 0 1 1 1
    输出是：
    (0,0,0)-(1,1,1)=1.73
    但是如果输入：
    2
    1 1 1 0 0 0
    输出应该是：
    (1,1,1)-(0,0,0)=1.73
2. 如果有两对点p1,p2和p3,p4的距离相同，则先输出在输入数据中靠前的点对。

    比如输入：
3
0 0 0 0 0 1 0 0 2
    输出是：
    (0,0,0)-(0,0,2)=2.00
    (0,0,0)-(0,0,1)=1.00
    (0,0,1)-(0,0,2)=1.00
    如果输入变成：
    3
    0 0 2 0 0 1 0 0 0
    则输出应该是：
    (0,0,2)-(0,0,0)=2.00
    (0,0,2)-(0,0,1)=1.00
    (0,0,1)-(0,0,0)=1.00


 * 思路分析：
 *  1、如何求出两两之间的距离。
 *      a[0] 和其余所有的
 *      a[1] 和a[2]之后的
 *      a[2] 和a[3]之后的
 *  2、求两点距离公式
 *
 *  3、对于一行输出中的两个点(x1,y1,z1)和(x2,y2,z2)，点(x1,y1,z1)在输入数据中应出现在点(x2,y2,z2)的前面。
 *      遍历时候，从前边输出即可
 *  4、如果有两对点p1,p2和p3,p4的距离相同，则先输出在输入数据中靠前的点对。
 *      第二层遍历，从后向前遍历
 */
#include <stdio.h>
#include <math.h>
int main()
{
    int n,a[100];
    scanf("%d",&n);
    //输入数组数据
    for (int i = 0; i < 3*n; ++i) {
        scanf("%d",&a[i]);
    }
    //
    for (int j = 0; j < 3*n-3; j+=3) {
        double d = 0.0;
        for (int i = 3*n-3; i >= j+3; i-=3) {
            //
            d = sqrt(((a[j]-a[i])*(a[j]-a[i]))+((a[j+1]-a[i+1])*(a[j+1]-a[i+1]))+((a[j+2]-a[i+2])*(a[j+2]-a[i+2])));
            printf("(%d,%d,%d)-(%d,%d,%d)=%.2f\n",a[j],a[j+1],a[j+2],a[i],a[i+1],a[i+2],d);
        }
    }
    return 0;
}
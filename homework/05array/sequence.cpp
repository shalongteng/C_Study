///**
// *Description
//输入一个长度为N的整数序列 (不多于128个整数)，每个整数的范围在[-10^52,10^52]，计算这个序列的众数。
//
//如果有多个数出现的次数都达到最多，则取在原序列最先出现的数为众数；如果所有的数都相等，则返回"no"。
//Input
//第一行为序列长度N。
//
//然后是N个数据， 注意，这N个数之间可能有若干个空行隔开。
//
//注意，输入数据可能有一些冗余表达信息，具体来说：
//
//1） 正数和0前面可能有前导0和'+'符号，例如
//+000123=123
//+0000=0
//-0000=0
//2）每个数字中不含有空格和其他非数字字符，例如不会出现"100 0"或者"- 100"。
//3）每个数字前面至多有一个符号，即不会出现+(-1)、-(+4)和-(-1)等情况。
//Output
//输出只有 1 行：
//
//该序列的众数或者”no”。
//
//如果有多个数出现的次数都达到最多，则取最先出现的数为众数，并且输出形式应该最简形式。
//
//例如，如果原序列众数为+000123，则输出123；如果原序列众数为+0000或者-0000或者0000,输出0。
//
//负数正常输出，例如：如果原序列众数为-000000001111，就输出-1111。
//Sample Input
//6
//-00001
//10000
//00011111111111111111111111111111111111
//-01
//+000000011111111111111111111111111111111111
//-00000000000001
//Sample Output
//-1
//Hint
//-1出现3次
//n+
// 解题思路：
//    1、如果只是 统计一些数据中 某些数字出现次数，可以定义一个二维数组，n行两列，第一列存放数据，第二列存放数字出现次数
//    2 但是本题，数据是字符串，并且可能有多余的前缀字符,所以需要化简字符串，然后进行比较，记录出现次数
//    3、化简方法。首先判断正负号，然后看是否为0，
//  心得：
//    程序错了，就老老实实打断点，用眼睛看，很难看出来bug在哪里
// */
//#include <stdio.h>
//#include <iostream>
//#include <string.h>
//using namespace std;
//void simplify(char a []);
//int main()
//{
//    char dest [100];
//    string s[10];
//    int n;
//    scanf("%d",&n);
//
//    for (int i = 0; i < n; ++i) {
//        char a [100];
//        scanf("%s",a);
//        //跳过空字符串
//        if(strcmp(a,"")==0)
//            continue;
//        //化简字符串
//        simplify(a);
//        s[i] = a;
//    }
//
//    return 0;
//}
///**
// * 完成对输入的每个数字进行化简的工作 .结果放在原数组
// * @param a 原数组
// */
//void simplify(char a [])
//{
//    int  flag = -1;//表示没有符号 0表示负号-  1表示+
//    int len = strlen(a);//记录字符串长度
//    int  d = 0;//记录初始不为零的下标
//    char dest [100];
//
//    //记录符号位
//    if(a[0] == '+')
//        flag = 1;
//    else if(a[0] == '-')
//        flag = 0;
//    else
//        flag = -1;
//
//    for (int i = 0; i < len; ++i)
//    {
//        //跳过符号位
//        if(flag != -1)
//        {
//            if(a[i+1] == '0')
//                continue;
//            else{
//                d = i+1;
//                break;
//            }
//
//        } else
//        {
//            if(a[i] == '0')
//                continue;
//            else{
//                d = i;
//                break;
//            }
//        }
//    }
//    if(flag == 1 || flag == 0)
//    //拷贝 到原数组
//        strcpy(&a[1],&a[d]);
//    else
//        strcpy(&a[0],&a[d]);
//    printf("%s\n",a);
//}
//
//
//
//
//
